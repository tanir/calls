<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <link rel="stylesheet" href="/common.css" />
  <title>Комната видеозвонка</title>
  <style>
    :root{
      color-scheme: light dark;
      --header-h:56px; --controls-h:72px; --pad:10px;

      /* ШИРИНА превью остаётся прежней, ВЫСОТА увеличена в 2 раза:
         высота = ширина * 1.125 (т.к. (9/16)*2 = 1.125) */
      --pip-w-desktop:180px;
      --pip-w-mobile:120px;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,sans-serif;background:#0b0b0c;color:#fff}

    header{
      position:sticky;top:0;z-index:5;display:flex;gap:8px;align-items:center;justify-content:space-between;
      height:var(--header-h);padding:8px max(10px,env(safe-area-inset-right)) 8px max(10px,env(safe-area-inset-left));
      background:#111317;border-bottom:1px solid #ffffff14;
    }
    .roomid{font-size:.95rem;opacity:.85;overflow:hidden;text-overflow:ellipsis;white-space:nowrap}
    .actions{display:none}

    button{
      background:#1f232a;color:#fff;border:1px solid #ffffff22;padding:10px 12px;border-radius:12px;cursor:pointer;min-height:44px;
      touch-action:manipulation;display:inline-flex;align-items:center;gap:8px
    }
    button:active{transform:translateY(1px)}
    /* .btn-icon svg sizing moved to common.css */
    .danger{background:#b3261e;border-color:#b3261e}

    /* Переключение иконок on/off */
    .icon.off-ico{display:none}
    .btn-icon.off .on-ico{display:none}
    .btn-icon.off .off-ico{display:inline}

    .layout{display:grid;grid-template-columns:1fr;gap:10px;padding:var(--pad);min-height:auto;padding-bottom:calc(var(--controls-h)+8px)}
    .video-wrap{
      position:relative;background:#0e1014;border:1px solid #ffffff14;border-radius:0;
      display:grid;place-items:center;overflow:hidden;min-height:240px;
      height:calc(var(--vh,100svh) - var(--header-h) - var(--controls-h) - env(safe-area-inset-top));
      border-left:0;border-right:0
    }

    /* Видео заполняет контейнер, удалённое — без обрезки */
    video{width:100%;height:100%;object-fit:cover}
    #remoteVideo{object-fit:contain;background:#000}

    /* Локальное превью: ширина как прежде, высота = ширина * 1.125 (в 2 раза выше от исходной 16:9) */
    .local{
      position:absolute;right:12px;bottom:12px;z-index:4;
      width:var(--pip-w-mobile) !important;
      height:calc(var(--pip-w-mobile) * 1.125) !important;
      object-fit:cover;border:1px solid #ffffff2a;border-radius:12px;overflow:hidden;
      box-shadow:0 8px 30px #00000066;pointer-events:none;background:#000
    }

    /* Оверлеи */
    .overlay{position:absolute;inset:0;display:grid;place-items:center;background:#0006;backdrop-filter:blur(2px)}
    .overlay.hidden{display:none}
    .overlay button{font-size:1rem;padding:14px 18px;border-radius:14px}

    /* Плашка «Включи микрофон» */
    .mic-hint{
      position:absolute;left:50%;top:12px;transform:translateX(-50%);
      background:#b3261ee6;color:#fff;border:1px solid #ffffff44;border-radius:12px;
      padding:8px 12px;font-weight:600;z-index:6;backdrop-filter:saturate(1.2) blur(2px)
    }
    .mic-hint.hidden{display:none}

    .sidebar{display:grid;grid-auto-rows:min-content;gap:10px;min-height:0}
    .card{padding:12px;background:#111317;border:1px solid #ffffff14;border-radius:14px}
    .status{font-size:.95rem;opacity:.9}

    .controls{
      position:fixed;left:0;right:0;bottom:0;z-index:6;display:block;background:#111317cc;backdrop-filter:blur(10px);
      border-top:1px solid #ffffff22;padding:8px max(10px,env(safe-area-inset-right)) calc(8px + env(safe-area-inset-bottom)) max(10px,env(safe-area-inset-left));
      height:var(--controls-h)
    }
    .controls .row{display:grid;grid-template-columns:1fr 1fr 1fr auto;gap:8px}
    .controls button{width:100%}

    /* Убрана узкая правая колонка на средних экранах */
    /* @media(max-width:1024px){.layout{grid-template-columns:1fr 260px}} */
    @media(max-width:900px){
      .sidebar{order:2}
      /* Компактная кнопка «Завершить» без лишнего пустого места */
      #hangupM{width:auto;justify-content:center;padding:12px;min-width:56px}
      header{border-radius:0}
      body{background:#0e1014}
    }

    button:focus-visible{outline:2px solid #7aa2ff;outline-offset:2px}
  </style>
</head>
<body>
  <header>
    <div class="roomid">Комната: <span id="roomLabel"></span></div>
    <div class="actions">
      <button id="copyLink" class="btn-icon" aria-label="Скопировать ссылку">
        <svg class="icon on-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M10 13a5 5 0 0 0 7.07 0l2.12-2.12a5 5 0 0 0-7.07-7.07L10.5 5"/>
          <path d="M14 11a5 5 0 0 0-7.07 0L4.8 13.13a5 5 0 1 0 7.07 7.07L13.5 19"/>
        </svg>
        <span class="label">Скопировать</span>
      </button>

      <button id="toggleCam" class="btn-icon" aria-pressed="true" aria-label="Выключить камеру">
        <svg class="icon on-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 7a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
          <path d="M17 9l5-3v12l-5-3z"/>
        </svg>
        <svg class="icon off-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M1 1l22 22"/><path d="M3 7a2 2 0 0 1 2-2h7"/>
          <path d="M16 16H5a2 2 0 0 1-2-2V9"/><path d="M17 9l5-3v8"/>
        </svg>
        <span class="label">Камера</span>
      </button>

      <button id="toggleMic" class="btn-icon" aria-pressed="true" aria-label="Выключить микрофон">
        <svg class="icon on-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="9" y="2" width="6" height="12" rx="3"/><path d="M5 10v2a7 7 0 0 0 14 0v-2"/><path d="M12 19v3"/>
        </svg>
        <svg class="icon off-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M1 1l22 22"/><rect x="9" y="2" width="6" height="12" rx="3"/>
          <path d="M5 10v2a7 7 0 0 0 10.5 6.1"/><path d="M12 19v3"/>
        </svg>
        <span class="label">Микрофон</span>
      </button>

      <!-- «Завершить» — ТОЛЬКО иконка, без подписи -->
      <button id="hangup" class="danger btn-icon" aria-label="Завершить звонок">
        <svg class="icon on-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.8 19.8 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6A19.8 19.8 0 0 1 2.08 4.18 2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72c.12.81.31 1.6.57 2.36a2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.72-1.14a2 2 0 0 1 2.11-.45c.74.25 1.54.44 2.36.57A2 2 0 0 1 22 16.92z"/>
        </svg>
      </button>
    </div>
  </header>

  <main class="layout">
    <section class="video-wrap" id="videoWrap">
      <video id="remoteVideo" autoplay playsinline></video>
      <video id="localVideo" class="local" autoplay muted playsinline></video>

      <!-- Плашка «Включи микрофон» -->
      <div id="micHint" class="mic-hint hidden">Включи микрофон</div>

      <!-- Оверлей для автоплея (iOS/Safari) -->
      <div id="playOverlay" class="overlay hidden">
        <button id="startPlayback">Нажмите, чтобы начать</button>
      </div>
    </section>
    
  </main>

  <!-- Нижняя панель (мобильная) — у ВСЕХ кнопок подписи, кроме «Завершить» -->
  <nav class="controls" role="navigation" aria-label="Панель управления звонком">
    <div class="row">
      <button id="copyLinkM" class="btn-icon" aria-label="Скопировать ссылку">
        <svg class="icon on-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M10 13a5 5 0 0 0 7.07 0l2.12-2.12a5 5 0 0 0-7.07-7.07L10.5 5"/>
          <path d="M14 11a5 5 0 0 0-7.07 0L4.8 13.13a5 5 0 1 0 7.07 7.07L13.5 19"/>
        </svg>
        <span class="label">Ссылка</span>
      </button>
      <button id="toggleCamM" class="btn-icon" aria-pressed="true" aria-label="Выключить камеру">
        <svg class="icon on-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 7a2 2 0 0 1 2-2h9a2 2 0 0 1 2 2v10a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"/>
          <path d="M17 9l5-3v12l-5-3z"/>
        </svg>
        <svg class="icon off-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M1 1l22 22"/><path d="M3 7a2 2 0 0 1 2-2h7"/>
          <path d="M16 16H5a2 2 0 0 1-2-2V9"/><path d="M17 9l5-3в8"/>
        </svg>
        <span class="label">Камера</span>
      </button>
      <button id="toggleMicM" class="btn-icon" aria-pressed="true" aria-label="Выключить микрофон">
        <svg class="icon on-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="9" y="2" width="6" height="12" rx="3"/><path d="M5 10v2a7 7 0 0 0 14 0v-2"/><path d="M12 19v3"/>
        </svg>
        <svg class="icon off-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M1 1l22 22"/><rect x="9" y="2" width="6" height="12" rx="3"/>
          <path d="M5 10v2a7 7 0 0 0 10.5 6.1"/><path d="M12 19v3"/>
        </svg>
        <span class="label">Микрофон</span>
      </button>
      <button id="hangupM" class="danger btn-icon" aria-label="Завершить звонок">
        <svg class="icon on-ico" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M22 16.92v3a2 2 0 0 1-2.18 2 19.8 19.8 0 0 1-8.63-3.07 19.5 19.5 0 0 1-6-6A19.8 19.8 0 0 1 2.08 4.18 2 2 0 0 1 4.11 2h3a2 2 0 0 1 2 1.72c.12.81.31 1.6.57 2.36a2 2 0 0 1-.45 2.11L8.09 9.91a16 16 0 0 0 6 6l1.72-1.14a2 2 0 0 1 2.11-.45c.74.25 1.54.44 2.36.57A2 2 0 0 1 22 16.92z"/>
        </svg>
      </button>
    </div>
  </nav>

  <script>
    /* корректная высота на мобилках */
    function setVh(){const h=(window.visualViewport?.height||window.innerHeight);document.documentElement.style.setProperty('--vh',h+'px')}
    setVh();window.addEventListener('resize',setVh);window.addEventListener('orientationchange',setVh);

    const qs=new URLSearchParams(location.search);
    let roomId=qs.get('room'); let token=qs.get('token');

    // Определяем тип комнаты из URL или по умолчанию 'video'
    roomType = qs.get('type') || 'video';
    console.log('🏠 Room type:', roomType);

    const roomLabel=document.getElementById('roomLabel'); const statusEl=document.getElementById('status');
    const copyBtn=document.getElementById('copyLink'); const camBtn=document.getElementById('toggleCam'); const micBtn=document.getElementById('toggleMic'); const hangupBtn=document.getElementById('hangup');
    const copyBtnM=document.getElementById('copyLinkM'); const camBtnM=document.getElementById('toggleCamM'); const micBtnM=document.getElementById('toggleMicM'); const hangupBtnM=document.getElementById('hangupM');

    const localVideo=document.getElementById('localVideo'); const remoteVideo=document.getElementById('remoteVideo');
    const overlay=document.getElementById('playOverlay'); const startPlaybackBtn=document.getElementById('startPlayback');
    const micHint=document.getElementById('micHint');

    // Упрощено: ждём room/token только из query

    let ws,pc,localStream; let role='guest'; let isCamOn=true,isMicOn=true; let offerStarted=false;
    let relayMode=false; let iceRestartTried=false; let relaySwitchTried=false;
    let connectionTimer=null; let isRussianUser=false; let isSafari=false; let roomType='video';

    // Множественные STUN/TURN серверы для лучшей совместимости с Россией
    let iceServers = [
      // Основные STUN серверы Google (могут быть заблокированы в РФ)
      { urls: 'stun:stun.l.google.com:19302' },
      { urls: 'stun:stun1.l.google.com:19302' },
      { urls: 'stun:stun2.l.google.com:19302' },
      { urls: 'stun:stun3.l.google.com:19302' },
      { urls: 'stun:stun4.l.google.com:19302' },

      // Альтернативные STUN серверы
      { urls: 'stun:stun.stunprotocol.org:3478' },
      { urls: 'stun:stun.voxgratia.org:3478' },
      { urls: 'stun:stun.xten.com:3478' },
      { urls: 'stun:stun.sipnet.net:3478' },
      { urls: 'stun:stun.ideasip.com:3478' },
      { urls: 'stun:stun.iptel.org:3478' },
      { urls: 'stun:stun.softjoys.com:3478' },
      { urls: 'stun:stunserver.org:3478' },

      // TURN серверы (работают даже через NAT/firewall)
      { urls: 'turn:turn.bistri.com:80', username: 'homeo', credential: 'homeo' },
      { urls: 'turn:turn.anyfirewall.com:443?transport=tcp', username: 'webrtc', credential: 'webrtc' },
      { urls: 'turn:numb.viagenie.ca:3478', username: 'numb', credential: 'numbviagenie' },
      { urls: 'turn:turn01.hubl.in:3478', username: 'hubl', credential: 'hubl' },

      // Российские TURN серверы (если доступны)
      { urls: 'turn:turn.russianvoicechat.com:3478', username: 'guest', credential: 'guest' },

      // Основной TURN сервер проекта
      { urls: ['turn:64.226.121.112:3478'], username: 'webrtcuser', credential: '' }
    ];

    async function loadTurn(){
      try{
        const r=await fetch('/api/turn');
        if(r.ok){
          const d=await r.json();
          if(Array.isArray(d.iceServers)) {
            // Добавляем загруженные серверы к существующим
            iceServers = [...iceServers, ...d.iceServers];
          }
        }
      }catch{}
    }

    // Определяем, является ли пользователь из России
    function detectRussianUser(){
      const lang = navigator.language || navigator.userLanguage;
      const timezone = Intl.DateTimeFormat().resolvedOptions().timeZone;
      return lang.startsWith('ru') || timezone.includes('Moscow') || timezone.includes('Europe/Moscow');
    }

    // Определяем Safari
    function detectSafari(){
      const ua = navigator.userAgent;
      return /^((?!chrome|android).)*safari/i.test(ua) || /Safari/i.test(navigator.vendor);
    }

    function setStatus(t){ if(statusEl) statusEl.textContent=t }
    function send(type,data){ws?.send(JSON.stringify({type,data,roomId,token}))}

    async function initMedia(){
      console.log('🎥 initMedia called, isSafari:', isSafari);

      try {
        isSafari = detectSafari();

        if (isSafari) {
          console.log('🧭 Safari detected, trying simplified access');
          setStatus('Safari обнаружен — получаем доступ к медиа...');

          // Для Safari используем упрощенный одновременный доступ
          console.log('🎥 Requesting combined media access for Safari...');
          try {
            localStream = await navigator.mediaDevices.getUserMedia({
              video: {
                width: { ideal: 640, max: 1280 },
                height: { ideal: 480, max: 720 },
                facingMode: 'user'
              },
              audio: {
                echoCancellation: false,
                noiseSuppression: false,
                autoGainControl: false
              }
            });
            console.log('✅ Safari media access successful, tracks:', localStream.getTracks().length);

            // Проверяем, что у нас есть и аудио и видео
            const audioTracks = localStream.getAudioTracks();
            const videoTracks = localStream.getVideoTracks();

            console.log('🎤 Audio tracks:', audioTracks.length, '📹 Video tracks:', videoTracks.length);

            if (audioTracks.length > 0) {
              setStatus('Микрофон и камера доступны');
            } else if (videoTracks.length > 0) {
              setStatus('Камера доступна (микрофон не найден)');
            } else {
              throw new Error('Ни аудио, ни видео треки не найдены');
            }

          } catch (safariError) {
            console.warn('❌ Safari media access failed:', safariError);

            // Попробуем получить только видео для Safari
            try {
              console.log('📹 Trying video-only access...');
              localStream = await navigator.mediaDevices.getUserMedia({
                video: {
                  width: { ideal: 640 },
                  height: { ideal: 480 }
                },
                audio: false
              });
              console.log('✅ Video-only access successful');
              setStatus('Камера доступна (микрофон отключен)');
            } catch (videoOnlyError) {
              console.error('❌ Video-only access also failed:', videoOnlyError);
              throw safariError; // Бросаем оригинальную ошибку
            }
          }

        } else {
          console.log('🌐 Non-Safari browser, using standard access');
          // Для других браузеров используем обычный подход
          localStream = await navigator.mediaDevices.getUserMedia({
            video: { width: 1280, height: 720 },
            audio: { echoCancellation: true, noiseSuppression: true }
          });
          console.log('✅ Standard access successful, tracks:', localStream.getTracks().length);
        }

        // Устанавливаем поток в видеоэлемент (если он существует)
        if (localVideo && !roomType) { // roomType проверка для видео-комнат
          console.log('📺 Setting video element srcObject');
          localVideo.srcObject = localStream;
        }

        console.log('🎉 Media initialization completed successfully');
        setStatus('Медиа устройства готовы');

      } catch (error) {
        console.error('❌ Media access error:', error);
        console.error('Error name:', error.name);
        console.error('Error message:', error.message);

        // Проверяем, возможно доступ уже есть, но ошибка в другом месте
        if (localStream && localStream.getTracks().length > 0) {
          console.log('⚠️  Stream exists but error occurred, tracks:', localStream.getTracks().length);
          const audioTracks = localStream.getAudioTracks().length;
          const videoTracks = localStream.getVideoTracks().length;
          console.log(`🎤 Audio: ${audioTracks}, 📹 Video: ${videoTracks}`);

          if (audioTracks > 0 || videoTracks > 0) {
            setStatus('Медиа доступен, но произошла ошибка');
            return; // Не выбрасываем ошибку, продолжаем
          }
        }

        // Проверяем разрешения для Safari
        if (isSafari) {
          console.log('🔍 Checking Safari permissions...');
          try {
            const permissions = await navigator.permissions.query({ name: 'camera' });
            console.log('📹 Camera permission:', permissions.state);
            const micPermissions = await navigator.permissions.query({ name: 'microphone' });
            console.log('🎤 Microphone permission:', micPermissions.state);
          } catch (permError) {
            console.log('⚠️  Permissions API not available');
          }
        }

        let errorMessage = 'Не удалось получить доступ к камере/микрофону. ';

        if (error.name === 'NotAllowedError') {
          errorMessage += 'Разрешите доступ в настройках браузера.';
        } else if (error.name === 'NotFoundError') {
          errorMessage += 'Камера или микрофон не найдены.';
        } else if (error.name === 'NotReadableError') {
          errorMessage += 'Устройства заняты другим приложением.';
        } else if (error.name === 'OverconstrainedError') {
          errorMessage += 'Запрошенные настройки не поддерживаются.';
        } else {
          errorMessage += 'Проверьте настройки браузера и разрешения.';
        }

        alert(errorMessage);

        // Для Safari показываем дополнительные инструкции
        if (isSafari) {
          const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
          let safariMessage = 'Для Safari:\n';

          if (isIOS) {
            safariMessage += '• В iOS Safari коснитесь адресной строки и выберите "Разрешить доступ к камере"\n';
            safariMessage += '• Или откройте настройки Safari > Конфиденциальность > Камера/Микрофон\n';
          } else {
            safariMessage += '• В меню Safari выберите "Настройки для этого сайта"\n';
            safariMessage += '• Разрешите доступ к камере и микрофону\n';
          }

          safariMessage += '• Обновите страницу и попробуйте снова';
          safariMessage += '\n\nОткройте Консоль разработчика (Cmd+Opt+C) для детальной информации.';

          alert(safariMessage);

          // Добавляем кнопку для повторной попытки
          const retryButton = document.createElement('button');
          retryButton.textContent = 'Повторить доступ к медиа';
          retryButton.style.cssText = `
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 12px 20px;
            background: #007AFF;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            z-index: 10000;
          `;
          retryButton.onclick = async () => {
            retryButton.remove();
            try {
              await initMedia();
              if (typeof createPeer === 'function') {
                await createPeer();
              }
              setStatus('Медиа устройства готовы — подключаемся...');
            } catch (retryError) {
              console.error('Retry failed:', retryError);
              alert('Повторная попытка не удалась. Проверьте настройки браузера.');
            }
          };
          document.body.appendChild(retryButton);
        }

        throw error;
      }
    }

    function preferH264(pc){
      const caps=RTCRtpSender.getCapabilities&&RTCRtpSender.getCapabilities('video');
      if(!caps||!caps.codecs) return;
      const h264=caps.codecs.filter(c=>(c.mimeType||'').toLowerCase()==='video/h264');
      if(!h264.length) return;
      const others=caps.codecs.filter(c=>(c.mimeType||'').toLowerCase()!=='video/h264');
      pc.getTransceivers().forEach(t=>{ if(t?.receiver?.track?.kind==='video'&&t.setCodecPreferences){ try{ t.setCodecPreferences([...h264,...others]) }catch{} }});
    }

    function ensurePlayback(){
      if (!remoteVideo) return; // Если видео удалено, не выполняем

      const tryPlay=()=>{
        remoteVideo.volume = isSpeakerOn ? 1.0 : 0.0;
        remoteVideo.play().then(()=>{
          if (overlay) overlay.classList.add('hidden');
        }).catch((error)=>{
          console.log('Playback failed:', error);
          if (overlay) overlay.classList.remove('hidden');

          // Для Safari добавляем специальную обработку
          if (isSafari && startPlaybackBtn) {
            startPlaybackBtn.textContent = 'Нажмите для начала воспроизведения (Safari)';
            startPlaybackBtn.style.display = 'block';
          }
        });
      };

      // Для Safari делаем дополнительную попытку после user interaction
      if (isSafari) {
        const userInteractionHandler = () => {
          tryPlay();
        };

        document.addEventListener('touchstart', userInteractionHandler, { once: true });
        document.addEventListener('click', userInteractionHandler, { once: true });
      }

      tryPlay();
      if (remoteVideo) remoteVideo.addEventListener('loadedmetadata',tryPlay,{once:true});
      if (startPlaybackBtn) startPlaybackBtn.addEventListener('click',tryPlay);
      document.addEventListener('visibilitychange',()=>{ if(!document.hidden) tryPlay() })
    }

    function createPeer(){
      pc=new RTCPeerConnection({iceServers, iceTransportPolicy: relayMode?'relay':'all'});
      localStream.getTracks().forEach(track=>pc.addTrack(track,localStream));
      preferH264(pc);

      pc.ontrack=(ev)=>{
        const [stream]=ev.streams;
        if(stream && remoteVideo.srcObject!==stream){ remoteVideo.srcObject=stream; ensurePlayback(); }
      };
      pc.onicecandidate=(ev)=>{ if(ev.candidate) send('candidate',{candidate:ev.candidate}) };
      pc.oniceconnectionstatechange=async()=>{
        const s=pc.iceConnectionState;
        if(s==='failed'){
          setStatus('ICE failed — пытаемся восстановить…');
          if(!iceRestartTried){
            try{
              iceRestartTried=true;
              const offer=await pc.createOffer({iceRestart:true});
              await pc.setLocalDescription(offer); send('offer',offer);
            }catch(e){ console.error('iceRestart',e); }
          } else if(!relaySwitchTried){
            relaySwitchTried=true;
            send('force-relay',{});
            switchToRelay();
          }
        }
      };
      pc.onconnectionstatechange=()=>{
        const s=pc.connectionState;
        if(s==='connected') {
          setStatus('Соединение установлено');
          // Очищаем таймер при успешном подключении
          if(connectionTimer) {
            clearTimeout(connectionTimer);
            connectionTimer = null;
          }
        }
        if(s==='disconnected'||s==='failed') setStatus('Связь потеряна. Обновите страницу.')
      };
    }

    async function start(){
      console.log('🚀 Starting application...');
      roomLabel.textContent=roomId||'—';
      if(!roomId||!token){
        console.log('❌ Missing roomId or token');
        alert('Неверная ссылка: отсутствует room или token.');
        location.href='/';
        return;
      }

      // Проверяем HTTPS для Safari
      if (isSafari && location.protocol !== 'https:' && location.hostname !== 'localhost') {
        console.log('❌ Safari requires HTTPS');
        alert('Safari требует HTTPS для доступа к камере и микрофону. Пожалуйста, используйте HTTPS версию сайта.');
        return;
      }

      console.log('🔍 Detecting user location...');
      // Определяем пользователя и устанавливаем relay режим при необходимости
      isRussianUser = detectRussianUser();
      if(isRussianUser){
        console.log('🇷🇺 Russian user detected, enabling TURN mode');
        setStatus('Обнаружен пользователь из РФ — используем TURN серверы…');
        relayMode = true;
      }

      try {
        console.log('📡 Loading TURN servers...');
        await loadTurn();

        console.log('🎥 Initializing media...');
        await initMedia();

        console.log('🔗 Creating peer connection...');
        createPeer();

        console.log('🌐 Connecting to signaling server...');
        ws=new WebSocket(`${location.protocol==='https:'?'wss':'ws'}://${location.host}`);
        ws.onopen=()=>{
          console.log('✅ WebSocket connected, joining room...');
          send('join',{roomId,token});
          setStatus('Подключаемся к комнате…');
        };

      } catch (error) {
        console.error('❌ Start failed:', error);
        // Если initMedia прошла успешно, но createPeer/WS failed, продолжаем
        if (localStream && localStream.getTracks().length > 0) {
          console.log('⚠️  Media available but connection failed, continuing...');
          setStatus('Медиа готовы, но подключение не удалось');
        } else {
          throw error;
        }
      }
      ws.onmessage=async(ev)=>{
        const msg=JSON.parse(ev.data);
        switch(msg.type){
          case 'joined':
            role=msg.role;
            setStatus(role==='host'?'Вы первый в комнате. Ждём второго участника…':'Второй участник. Готовим соединение…');

            // Для российских пользователей или при проблемах с подключением
            // устанавливаем таймер на переключение в relay режим через 10 секунд
            if(isRussianUser || relayMode){
              connectionTimer = setTimeout(() => {
                if(pc && pc.connectionState !== 'connected' && !relaySwitchTried){
                  setStatus('Проблемы с подключением — переключаемся на TURN…');
                  send('force-relay',{});
                  switchToRelay();
                }
              }, 10000);
            }
            break;
          case 'peer-joined':
            setStatus('К вам присоединились. Готовим соединение…');
            if(role==='host' && !offerStarted){
              try{
                offerStarted=true;
                const offer=await pc.createOffer();
                await pc.setLocalDescription(offer);
                send('offer',offer);
                setStatus('Отправлен оффер (host)…');
              }catch(e){ console.error('host offer', e); offerStarted=false; }
            }
            break;
          case 'ready':
            if(role==='guest' && !offerStarted){
              try{
                offerStarted=true;
                const offer=await pc.createOffer(); await pc.setLocalDescription(offer); send('offer',offer); setStatus('Отправлен оффер (guest)…');
              }catch(e){ console.error('guest offer', e); offerStarted=false; }
            }
            break;
          case 'offer':
            if(role==='host'){ await pc.setRemoteDescription(new RTCSessionDescription(msg.data)); const answer=await pc.createAnswer(); await pc.setLocalDescription(answer); send('answer',answer); setStatus('Отправлен ответ…'); }
            break;
          case 'answer': await pc.setRemoteDescription(new RTCSessionDescription(msg.data)); setStatus('Идёт установление соединения…'); break;
          case 'candidate': try{ await pc.addIceCandidate(new RTCIceCandidate(msg.data.candidate)) }catch(e){ console.error('addIceCandidate',e) } break;
          case 'force-relay':
            if(!relayMode){ switchToRelay(); }
            break;
          case 'leave':
            setStatus('Собеседник положил трубку.');
            cleanup(true);
            break;
          case 'full': alert('Комната уже занята двумя участниками.'); location.href='/'; break;
          case 'error': alert('Ошибка: '+(msg.message||'неизвестно')); break;
        }
      };
      ws.onclose=()=>setStatus('Сигналинг отключён. Перезагрузите страницу.');
    }

    function switchToRelay(){
      try{ pc?.close(); }catch{}
      offerStarted=false; // позволим инициировать заново
      relayMode=true; // только TURN
      createPeer();
      (async()=>{ try{ const offer=await pc.createOffer(); await pc.setLocalDescription(offer); send('offer',offer); setStatus('Оффер через TURN…'); }catch(e){ console.error('relay offer',e) } })();
    }

    /* UI-состояния */
    function updateCamUi(){
      [camBtn,camBtnM].forEach(b=>{ if(!b)return; b.classList.toggle('off',!isCamOn); b.setAttribute('aria-pressed',String(isCamOn)); b.setAttribute('aria-label',isCamOn?'Выключить камеру':'Включить камеру'); });
    }
    function updateMicUi(){
      [micBtn,micBtnM].forEach(b=>{ if(!b)return; b.classList.toggle('off',!isMicOn); b.setAttribute('aria-pressed',String(isMicOn)); b.setAttribute('aria-label',isMicOn?'Выключить микрофон':'Включить микрофон'); });
      micHint.classList.toggle('hidden', isMicOn);
    }

      async function copyLink(){ try{ await navigator.clipboard.writeText(location.href); showToast('Ссылка скопирована') }catch{} }
      function toggleCam(){ isCamOn=!isCamOn; localStream.getVideoTracks().forEach(t=>t.enabled=isCamOn); updateCamUi(); }
      function toggleMic(){ isMicOn=!isMicOn; localStream.getAudioTracks().forEach(t=>t.enabled=isMicOn); updateMicUi(); }
      function safeClose(){ window.close(); setTimeout(()=>{ location.href='/' },100); }
      function cleanup(remote=false){
        if(remoteVideo.srcObject){ remoteVideo.srcObject.getTracks().forEach(t=>t.stop()); remoteVideo.srcObject=null; }
        pc?.getSenders()?.forEach(s=>s.track&&s.track.stop());
        pc?.close();
        ws?.close();
        if(remote) safeClose();
      }
      function hangup(){ send('leave',{}); cleanup(false); safeClose(); }

    function bind(el,fn){ el&&el.addEventListener('click',fn) }
    bind(copyBtn,copyLink); bind(copyBtnM,copyLink);
    bind(camBtn,toggleCam); bind(camBtnM,toggleCam);
    bind(micBtn,toggleMic); bind(micBtnM,toggleMic);
    bind(hangupBtn,hangup); bind(hangupBtnM,hangup);

    function showToast(text){
      const t=document.createElement('div'); t.textContent=text;
      Object.assign(t.style,{position:'fixed',left:'50%',bottom:`calc(var(--controls-h,72px) + 16px + env(safe-area-inset-bottom))`,transform:'translateX(-50%)',background:'#1f232a',color:'#fff',border:'1px solid #ffffff33',borderRadius:'12px',padding:'10px 14px',zIndex:9,boxShadow:'0 10px 30px #0008'});
      document.body.appendChild(t); setTimeout(()=>t.remove(),1200);
    }

    updateCamUi(); updateMicUi();
    start().catch(err=>{ console.error(err); alert('Не удалось получить доступ к камере/микрофону. Проверьте разрешения.') });
  </script>
</body>
</html>
